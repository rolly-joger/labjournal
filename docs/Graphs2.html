<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />



<meta name="date" content="2024-09-25" />

<title>Graphs 2: Electric Boogaloo</title>

<script src="site_libs/header-attrs-2.28/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/paper.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.13.2/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-6.4.2/css/all.min.css" rel="stylesheet" />
<link href="site_libs/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>




<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>


<link rel="stylesheet" href="tweaks.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html"></a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">
    <span class="fa fa-home"></span>
     
  </a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Workshop Content
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="Week1.html">Week 1</a>
    </li>
    <li>
      <a href="Week2.html">Week 2</a>
    </li>
    <li>
      <a href="Week3Webscraping.html">Week 3</a>
    </li>
    <li>
      <a href="Graphs2.html">Week 4</a>
    </li>
    <li>
      <a href="visualise.og.data.html">Week 5</a>
    </li>
    <li>
      <a href="week6.html">Week 6</a>
    </li>
    <li>
      <a href="week7.html">Week 7</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Dataprep
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="dataprep.final.html">The Data</a>
    </li>
    <li>
      <a href="making.gender.html">Making Gender</a>
    </li>
    <li>
      <a href="making.ethnicity.html">Making Ethnicity</a>
    </li>
    <li>
      <a href="h.index.html">h-Index</a>
    </li>
    <li>
      <a href="full.and.final.data.html">Final Dataset</a>
    </li>
    <li>
      <a href="all.descriptives.html">Descriptives</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    First Drafts
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="JournalWeekTwo.html">Introduction First Draft</a>
    </li>
    <li>
      <a href="IntroRSQ.html">Introduction, Revised</a>
    </li>
    <li>
      <a href="outline.final.paper.html">Preliminary Outline</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Final 'Paper'
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="final.intro.html">Introduction</a>
    </li>
    <li>
      <a href="final.tk.html">Theoretical Framework</a>
    </li>
    <li>
      <a href="final.datamethods.html">Data and Methods, Data</a>
    </li>
    <li>
      <a href="final.descriptives.for.paper.html">Data and Methods, Descriptives</a>
    </li>
    <li>
      <a href="descriptive.rsq.answer.html">Analysis et al. - Descriptive</a>
    </li>
    <li>
      <a href="explanatory.rsq.answer.html">Analysis et al. - RSiena</a>
    </li>
    <li>
      <a href="final.concl.disc.html">Conclusions</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/JochemTolsma/labjournal">
    <span class="fab fa-github"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
<li role="separator" class="divider"></li>
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Graphs 2: Electric Boogaloo</h1>
<h4 class="date">2024-09-25</h4>

</div>


<pre class="r"><code>library(igraph)
zach &lt;- igraph::make_graph()
plot(zach)</code></pre>
<pre class="r"><code>vcount(zach)
igraph::ecount(zach)
igraph::degree(zach)
transitivity(zach, type = c(&quot;localundirected&quot;), isolates = c(&quot;NaN&quot;, &quot;zero&quot;))
#igraph::betweenness(zach_adjacency)</code></pre>
<pre class="r"><code>igraph::dyad_census(zach) #mutual, asymetric, no relations between two vertices -- en als je 0 asymetrisch ziet, dan weet je undirected
#directed of undirected netwerk
#how is transitivity defined in een undirected netwerk
igraph::triad_census(zach)#so how are they &quot;doin&#39;&quot;
#triad.census(zach_adjacent) #lovely</code></pre>
<p>Now we calculate the global transitivity of the network. The formula
to achieve this is:</p>
<pre class="r"><code>transitivity(zach, type = &quot;global&quot;)
a &lt;- 1575
b &lt;- 3*45 +393
b/a</code></pre>
<div id="adjusting-the-graph" class="section level2" number="0.1">
<h2><span class="header-section-number">0.1</span> Adjusting the
Graph</h2>
<p>So, lets adjust the graph according to some aspects of the vertices
included.</p>
<pre class="r"><code>V(zach)$size &lt;-betweenness(zach, normalized = T, directed = F) * 60 + 10 #grote = *60, en de ander willen we wel zien, dus minimaal 10 (voor degene met 0)
igraph::plot.igraph(zach)</code></pre>
<p>Then we want the nodess to be further apart, so we can more easily
see what’s going one here</p>
<pre class="r"><code>set.seed(2345)
mds &lt;- layout_with_mds(zach)
igraph::plot.igraph(zach, layout = mds)#ok dit is nog steeds best lelijk eigenlijk, want 33 en 34 zitten op dezelfde plek -- te veel overlap</code></pre>
<p>… do something with the coordinates then</p>
<pre class="r"><code>mds
mds[1,1] &lt;- 4
mds[34,1] &lt;--3.5
igraph::plot.igraph(zach, layout = mds)</code></pre>
<pre class="r"><code>igraph::plot.igraph(zach, layout = mds, margin = c(0,0,0,0)) 
legend((x = &quot;bottom&quot;, c(&quot;Note: the position nodes 1 and 34 have been set by Jochem Tolsma (and reproduced by Hannah)\n to be set in a specific position -- and thus do not reflect the properties of the mds algoritm.&quot;), bty = &quot;n&quot;, cex = .6)</code></pre>
</div>
<div id="twittersphere-in-the-dutch-hop" class="section level1"
number="1">
<h1><span class="header-section-number">1</span> “Twittersphere in the
Dutch HoP”</h1>
<p>Get some of the X (formerly known as Twitter) info of Members of
Parliament, and info about the actors themselves.</p>
<pre class="r"><code>load(&quot;twitter_20190919.RData&quot;)
str(twitter_20190919, 1)</code></pre>
<p>Then extract some info about their characteristics.</p>
<pre class="r"><code>keyf &lt;- twitter_20190919[[1]] #df on 147 dutch mp&#39;s
twitter &lt;- twitter_20190919[[2]] #object we can analyse in RSiena
seats &lt;- twitter_20190919 [[3]] # coordinates of the seats in HoP
fnet &lt;- twitter$depvars$fnet # who follows whom
atmnet &lt;- twitter$depvars$atmnet # who atmentions whom
rtnet &lt;- twitter$depvars$rtnet # who retweats whom
vrouw &lt;- twitter$cCovars$vrouw #gender
partij &lt;- twitter$cCovars$partij #partij
ethminz &lt;- twitter$cCovars$ethminz #ethnic minority
lft &lt;- twitter$cCovars$lft #age 
#de-centralise values 
ethminz &lt;- ethminz + attributes(ethminz)$mean
partij &lt;- partij + attributes(partij)$mean
vrouw &lt;- vrouw + attributes(vrouw)$mean
lft &lt;- lft + attributes(lft)$mean</code></pre>
<p>Having extracted and defined the variables of import, we’ll now
investigate the dataset/structure of the data.</p>
<pre class="r"><code>str(fnet) #the structure of the friendship network
view(fnet)</code></pre>
<p>From all these data, we select very specific matrices: friendship
(follower) network wave 1, and the “<span
class="citation">@mentions</span>” for wave 1, 2, and 3 …</p>
<pre class="r"><code>fnet1 &lt;- fnet[, , 1]  #friendship network wave 1
atmnet1 &lt;- atmnet[, , 1]  #atmention network wave 1
# we will use wave 2 and 3 later.
atmnet2 &lt;- atmnet[, , 2] #atmention network wave 2
atmnet3 &lt;- atmnet[, , 3] #atmention network wave 3</code></pre>
<p>… and then, for our last trick, we replace missing values in
RSiena</p>
<pre class="r"><code>fnet1[fnet == 10] &lt;- 0
atmnet1[atmnet1 == 10] &lt;- 0
atmnet2[atmnet2 == 10] &lt;- 0
atmnet3[atmnet3 == 10] &lt;- 0</code></pre>
<div id="the-fun-stuff" class="section level2" number="1.1">
<h2><span class="header-section-number">1.1</span> The Fun Stuff</h2>
<p>Now were gonna do some real fun things, let’s begin by making a graph
from the atmnet1 information:</p>
<pre class="r"><code>atmnet1_graph &lt;- igraph::graph_from_adjacency_matrix(atmnet1, mode = &quot;directed&quot;, weighted = NULL, diag = T, add.colnames = NA, add.rownames = NA)

atmnet1_edges &lt;- as_data_frame(atmnet1_graph, what = &quot;edges&quot;)

keyf &lt;- cbind(keyf$EGOid, keyf[ ,names(keyf) != &quot;EGOid&quot;])

names(keyf)[1] &lt;- &quot;EGOid&quot;

atmnet1_graph &lt;- graph_from_data_frame(atmnet1_edges, directed = T, vertices = keyf)
#now plot!
plot(atmnet1_graph) #all those loners</code></pre>
<p>the downsize of the plot we have just … well … plotted, is that it is
horribly illegible. Let’s see if we can introduce some legibiliy to
induce some usefulness.</p>
<pre class="r"><code>#first, does [simplify] do anything?
atmnet1_graph &lt;- simplify(atmnet1_graph)
plot(atmnet1_graph) #something happens, nothing useful tho
edge_density(atmnet1_graph) #density of the network does not explain the density of the graph. so we&#39;re gonna have to find some other solutions</code></pre>
<div id="directed-and-reciprocated-ties-a-differentiation"
class="section level3" number="1.1.1">
<h3><span class="header-section-number">1.1.1</span> Directed and
reciprocated ties – a differentiation</h3>
<pre class="r"><code>atmnet1_un &lt;- atmnet1 == 1 &amp; t(atmnet1) == 1
atmnet1_graph2 &lt;- graph_from_adjacency_matrix(atmnet1_un, mode = &quot;undirected&quot;, weighted = NULL, diag = T, add.colnames = NA, add.rownames = NA)
edges_atmnet1_un &lt;- as_data_frame(atmnet1_graph2, what = &quot;edges&quot;)
atmnet1_graph2 &lt;- graph_from_data_frame(edges_atmnet1_un, directed = F, vertices = keyf)
plot(atmnet1_graph2) # a loopy bitch (self-mention)
atmnet1_graph2 &lt;- simplify(atmnet1_graph2)
plot(atmnet1_graph2, mode = &quot;undirected&quot;)</code></pre>
</div>
<div id="select-nodes-to-plot" class="section level3" number="1.1.2">
<h3><span class="header-section-number">1.1.2</span> Select Nodes to
Plot</h3>
<pre class="r"><code>#get rid of MP&#39;s who only mention themselves
diag(atmnet1_un) &lt;- 0
#find the noisolates (isolate?)
noisolates &lt;- rowSums(atmnet1_un, na.rm = T) &gt; 0
atmnet1_un_sel &lt;- atmnet1_un[noisolates, noisolates]
length(noisolates)
keyf_sel &lt;- keyf[noisolates, ]
atmnet1_graph2_sel &lt;- graph_from_adjacency_matrix(atmnet1_un_sel, mode = &quot;undirected&quot;, weighted = NULL, diag = T, add.colnames = NA, add.rownames = NA)
atmnet1_graph2_sel &lt;- simplify(atmnet1_graph2_sel)
plot(atmnet1_graph2_sel, mode = &quot;undirected&quot;)</code></pre>
<p>… or another characteristic – party (VVD):</p>
<pre class="r"><code># option 1: see above.  only select MPs from the liberal party
selection &lt;- keyf$Partij == &quot;VVD&quot;
# build new adjacency matrix
atmnet1_un_sel2 &lt;- atmnet1_un[selection, selection]
# etc.

# option 2. Suppose we have attached our dataset to our graph object.  only select MPs from the
# liberal party
selection &lt;- V(atmnet1_graph2_sel)$Partij == &quot;VVD&quot;
selection_id &lt;- which(selection)  # this gives us a numeric variable
G_sel &lt;- induced_subgraph(atmnet1_graph2_sel, v = selection_id)
plot(G_sel)</code></pre>
<p>… we can also change the size of the vertices …</p>
<pre class="r"><code>V(atmnet1_graph2_sel)$size &lt;- degree(atmnet1_graph2_sel)*1.3
plot(atmnet1_graph2_sel, mode = &quot;undirected&quot;)</code></pre>
<p>… or correlate colour and label …</p>
<pre class="r"><code>V(atmnet1_graph2)
V(atmnet1_graph2)$label &lt;-  as.character(V(atmnet1_graph2)$Naam2)
V(atmnet1_graph2)$label.cex = 1
V(atmnet1_graph2)$colour &lt;- ifelse(V(atmnet1_graph2)$Geslacht == &quot;vrouw&quot;, &quot;red&quot;, &quot;blue&quot;)
plot(atmnet1_graph2, mode = &quot;undirected&quot;)
#or not</code></pre>
<p>… curve the edges …</p>
<pre class="r"><code>E(atmnet1_graph2)$arrow.size = .4
E(atmnet1_graph2)$curved = .3
plot(atmnet1_graph2, mode = &quot;undirected&quot;) #ok i fucked up my edges somewhere along the way i guess</code></pre>
<p>… add a legend …</p>
<pre class="r"><code>plot.igraph(atmnet1_graph2, margin = 0, mode = &quot;udirected&quot;)
legend(x = -1, y = -1, c(&quot;Female&quot;, &quot;Male&quot;), pch = 21, col = &quot;#777777&quot;, pt.bg = c(&quot;red&quot;, &quot;green&quot;), pt.cex = 2,
    cex = 0.8, bty = &quot;n&quot;, ncol = 1)</code></pre>
</div>
</div>
</div>
<div id="parliament" class="section level1" number="2">
<h1><span class="header-section-number">2</span> Parliament</h1>
<pre class="r"><code>#knitr::include_graphics(&quot;TK.jpg&quot;)
plot(keyf$X, keyf$Y, xlim = c(-18, 18), ylim = c(-18, 18), col = keyf$Partij_col, pch = 16)</code></pre>
<p>adjust something</p>
<pre class="r"><code>#give nodes colour to parties
V(atmnet1_graph2)$color &lt;- keyf$Partij_col

# change node size a bit
V(atmnet1_graph2)$size = igraph::degree(atmnet1_graph2) * 1.05 + 6

# remove the labels
V(atmnet1_graph2)$label = &quot;&quot;

# less curvature
E(atmnet1_graph2)$curved = 0.1

owncoords &lt;- cbind(keyf$X, keyf$Y)
owncoords &lt;- owncoords/8
owncoords[, 1] &lt;- (owncoords[, 1] - mean(owncoords[, 1]))
owncoords[, 2] &lt;- (owncoords[, 2] - mean(owncoords[, 2]))
plot.igraph(atmnet1_graph2, mode = &quot;undirected&quot;, layout = owncoords, rescale = F, margin = c(0, 0, 0, 0), xlim = c(min(owncoords[,
    1]), max(owncoords[, 1])), ylim = c(min(owncoords[, 2]), max(owncoords[, 2])))</code></pre>
<p>… change some edges …</p>
<pre class="r"><code># construct adjacency matrix first define the recipricated atmentions in each wave
atmnet1_un &lt;- atmnet1 == 1 &amp; t(atmnet1) == 1
atmnet2_un &lt;- atmnet2 == 1 &amp; t(atmnet2) == 1
atmnet3_un &lt;- atmnet3 == 1 &amp; t(atmnet3) == 1

atmnet_weighted &lt;- atmnet1_un + atmnet2_un + atmnet3_un

# contstruct graph / let us keep the loops note that the parameter &#39;weighted&#39; is set to true.
G_w &lt;- igraph::graph_from_adjacency_matrix(atmnet_weighted, mode = &quot;undirected&quot;, weighted = TRUE, diag = TRUE,
    add.colnames = NA, add.rownames = NA)

# attach data
edges &lt;- igraph::as_data_frame(G_w, what = &quot;edges&quot;)
# inspect the weight.
edges$weight  #not a lot of variation. 

# rebuild the graph.
G_w &lt;- graph_from_data_frame(edges, directed = FALSE, vertices = keyf)



# add changes as above
V(G_w)$color &lt;- keyf$Partij_col
V(G_w)$size = igraph::degree(G_w) * 1.05 + 6
V(G_w)$label = &quot;&quot;
E(G_w)$curved = 0.1

# add the weights
E(G_w)$width &lt;- E(G_w)$weight

plot.igraph(G_w, mode = &quot;undirected&quot;, layout = owncoords, rescale = F, margin = c(0, 0, 0, 0), xlim = c(min(owncoords[,
    1]), max(owncoords[, 1])), ylim = c(min(owncoords[, 2]), max(owncoords[, 2])))</code></pre>
<p>… change the edges based on dyads …</p>
<pre class="r"><code># let us make them the color of the nodes if it is between nodes from same party.  let us make them
# red if between parties

edges &lt;- as_adjacency_matrix(G_w)
edges_mat &lt;- matrix(as.numeric(edges), nrow = nrow(edges))
# edges_mat

# because we have undirected, we only need the edges once ...I know ...
edges_mat[lower.tri(edges_mat)] &lt;- 0
# table(keyf$Geslacht)

teller &lt;- 1
coloredges &lt;- NA
# we will loop over egos
for (i in 1:nrow(edges)) {
    # We then loop over alters
    for (j in 1:ncol(edges)) {
        # we check if there is a tie between ego and alter
        if (edges_mat[i, j] == 1) {
            # if so, we check ego and alter are from the same party if so, we give the tie the
            # color of the party
            if (keyf$Partij_col[i] == keyf$Partij_col[j]) {
                coloredges[teller] &lt;- keyf$Partij_col[i]
            }
            # if so, we check ego and alter are from the same party if not, we give the tie a
            # transparent grey color
            if (keyf$Partij_col[i] != keyf$Partij_col[j]) {
                coloredges[teller] &lt;- &quot;#0000004B&quot;
            }
            teller &lt;- teller + 1
        }
    }
}

E(G_w)$color = coloredges

# prepare a legend
Party_names &lt;- unique(keyf$Partij)
Party_cols &lt;- unique(keyf$Partij_col)
# reorder
Party_names &lt;- Party_names[c(7, 3, 9, 10, 12, 11, 5, 4, 6, 2, 8, 1, 13)]
Party_cols &lt;- Party_cols[c(7, 3, 9, 10, 12, 11, 5, 4, 6, 2, 8, 1, 13)]

#save the plot png(&#39;MPplotv2.png&#39;,width = 900, height= 900)
{

    plot.igraph(G_w, mode = &quot;undirected&quot;, layout = owncoords, rescale = F, margin = c(0, 0, 0, 0), xlim = c(min(owncoords[,
        1]), max(owncoords[, 1])), ylim = c(min(owncoords[, 2]), max(owncoords[, 2])))

    legend(&quot;topleft&quot;, legend = Party_names, pch = 21, col = &quot;#777777&quot;, pt.bg = Party_cols, pt.cex = 2,
        cex = 0.8, bty = &quot;n&quot;, ncol = 3)

    text(-2.2, -1.2, &quot;Note 1: Node size based on degree&quot;, adj = 0, cex = 0.8)
    text(-2.2, -1.3, &quot;Note 2: Edge color based on Party of MPs, black if MPs from different party&quot;, adj = 0,
        cex = 0.8)
    text(-2.2, -1.4, &quot;Note 3: Edge width based on number of @mentions&quot;, adj = 0, cex = 0.8)
}

# dev.off()</code></pre>
</div>
<div id="collab.-networks" class="section level1" number="3">
<h1><span class="header-section-number">3</span> Collab. Networks</h1>
<pre class="r"><code># load the necessary datasets
load(&quot;soc_df.RData&quot;)
load(&quot;soc_collabs1.RData&quot;)
load(&quot;soc_collabs2.RData&quot;)</code></pre>
<pre class="r"><code># get unique collaborators of soc staff first
soc_collabs_unique &lt;- unique(soc_collabs[, 4])  # so 229 unique collaborators for RU staff?
soc_collabs_unique &lt;- c(soc_collabs_unique, soc_df$gs_id)  # add the soc staff themselves.
soc_collabs_unique &lt;- data.frame(soc_collabs_unique)
soc_collabs_unique$v1 &lt;- 1  # convenient to select on after the merge
soc_collabs_unique &lt;- unique(soc_collabs_unique)

# so this is a very important step, we join the unique soc collaborators to the collaborators of
# collaborators
require(tidyverse)
onefivedegree &lt;- left_join(collabs_1deep, soc_collabs_unique, by = c(coauth_id = &quot;soc_collabs_unique&quot;))

# Then, we drop those that are not among sociology collaborators and who don&#39;t lsit coauthors
# regardless
onefivedegree &lt;- onefivedegree[!is.na(onefivedegree$v1), ]
onefivedegree &lt;- onefivedegree[!is.na(onefivedegree$coauth), ]

# we pick those columns and have an edgelist of soc collaborators and whether they collaborate with
# those same collaborators the 1.5 degree network
onefivedegree &lt;- onefivedegree[, c(&quot;name&quot;, &quot;coauth&quot;)]
names(onefivedegree) &lt;- c(&quot;from&quot;, &quot;to&quot;)

# we get soc collaborators and add those to the data above and end up with a nice edgelist!
socc &lt;- soc_collabs[!is.na(soc_collabs$coauth), ]
socc &lt;- socc[, c(&quot;name&quot;, &quot;coauth&quot;)]
names(socc) &lt;- c(&quot;from&quot;, &quot;to&quot;)
onefivedegree &lt;- rbind(socc, onefivedegree)
save(onefivedegree, file = &quot;soc_onefivedegree.RData&quot;)</code></pre>
<pre class="r"><code>onefivedegree &lt;- as.matrix(onefivedegree)  # matrix because igraph wants that
library(igraph)  # Notice that we call igraph here, in anticipation of the viz tutorial.
net1 &lt;- graph_from_edgelist(onefivedegree, directed = TRUE)  # Notice the igraph function here!

plot(net1)  # pretty ugly!</code></pre>
<pre class="r"><code>plot(net1 ,
     vertex.color = &quot;gold&quot;, # nice color for the vertices
     vertex.size = 4,  # we&#39;ll vertices a bit smaller
     vertex.frame.color = &quot;gray&quot;,  # we&#39;ll put a gray frame around vertices
     vertex.label.color = &quot;black&quot;,  # not that ugly blue color for the labels (names)
     vertex.label.family = &quot;Helvetica&quot;, # not a fan of times new roman in figures
     vertex.label.cex = 0.4,  # make the label a bit smaller too
     vertex.label.dist = 0.5,  # we&#39;ll pull the labels a bit away from the vertices
     edge.curved = 0.2, # curved edges is always a nice touch
     edge.arrow.size = 0.1) # make arrow size (direction of edge) smaller</code></pre>
<pre class="r"><code>in_network &lt;- data.frame(as_ids(V(net1)))
names(in_network)[1] &lt;- &quot;name&quot;

#soc_df$total_cites &lt;- soc_df$total_cites.x
ru_nodes &lt;- soc_df[, c(&quot;name&quot;, &quot;total_cites&quot;)]
in_network &lt;- left_join(in_network, ru_nodes, by = c(&quot;name&quot; = &quot;name&quot;))
in_network$vcol &lt;- ifelse(is.na(in_network$total_cites), &quot;#E69F00&quot;, &quot;#56B4E9&quot;)

plot(net1,
     vertex.color = in_network$vcol, #THIS WAS WHAT WE DID THE LAST CODEBLOCK FOR!
     vertex.size = 4,  # we&#39;ll make them a bit smaller
     vertex.frame.color = &quot;gray&quot;,  # we&#39;ll put a frame around it
     vertex.label.color = &quot;black&quot;,  # not that ugly blue color for the names
     vertex.label.family = &quot;Helvetica&quot;, # not a fan of times in figures
     vertex.label.cex = 0.4,  # a bit smaller too
     vertex.label.dist = 0.5,  # we&#39;ll pull the labels a bit away from the vertices
     edge.curved = 0.2,  # curved edges is always a nice tough
     edge.arrow.size = 0.1) # arrow size smaller</code></pre>
<pre class="r"><code>plot(net1,
     vertex.color = in_network$vcol, 
     #NOTICE THESE CONDITIONAL STATEMENTS BELOW
     vertex.label = ifelse(!is.na(in_network$total_cites), in_network$name, NA),
     vertex.size = 4,  # we&#39;ll make them a bit smaller
     vertex.frame.color = &quot;gray&quot;,  # we&#39;ll put a frame around it
     vertex.label.color = &quot;black&quot;,  # not that ugly blue color for the names
     vertex.label.family = &quot;Helvetica&quot;, # not a fan of times in figures
     vertex.label.cex = 0.65,  # a bit smaller too
     vertex.label.dist = 0.5,  # we&#39;ll pull the labels a bit away from the vertices
     edge.curved = 0.2, # curved edges is always a nice tough
     edge.arrow.size = 0.1) # arrow size smaller</code></pre>
<pre class="r"><code>plot(net1,
     vertex.color = in_network$vcol, 
     vertex.label = ifelse(!is.na(in_network$total_cites), in_network$name, NA),
     # SAME HERE, TRY TO SMOOTH THE TOTAL_CITES A BIT WITH LOGSCALE
     vertex.size = ifelse(!is.na(in_network$total_cites), log(in_network$total_cites), 2),
     vertex.frame.color = &quot;gray&quot;,  # we&#39;ll put a frame around it
     vertex.label.color = &quot;black&quot;,  # not that ugly blue color for the names
     vertex.label.family = &quot;Helvetica&quot;, # not a fan of times in figures
     vertex.label.cex = 0.65,  # a bit smaller too
     vertex.label.dist = 0.5,  # we&#39;ll pull the labels a bit away from the vertices
     edge.curved = 0.2, # curved edges is always a nice tough
     edge.arrow.size = 0.1) # arrow size smaller</code></pre>
<pre class="r"><code>net1_mat &lt;- igraph::as_adjacency_matrix(net1, sparse = FALSE)

net1_un &lt;- (net1_mat + t(net1_mat)) &gt; 0

net1_un &lt;- graph_from_adjacency_matrix(net1_un, mode = &quot;undirected&quot;)

net_sel &lt;- induced.subgraph(net1_un, vids = (in_network$vcol == &quot;#56B4E9&quot;))


plot(net_sel)

clp &lt;- cluster_optimal(net_sel)


plot(clp, net_sel)</code></pre>
</div>

<div id="rmd-source-code">LS0tCnRpdGxlOiAiR3JhcGhzIDI6IEVsZWN0cmljIEJvb2dhbG9vIgpvdXRwdXQ6IGh0bWxfZG9jdW1lbnQKZGF0ZTogIjIwMjQtMDktMjUiCi0tLQoKYGBge3IsIGluY2x1ZGU9RkFMU0V9CmtuaXRyOjpvcHRzX2NodW5rJHNldCgKIGV2YWwgPSBGCikKYGBgCgpgYGB7ciByZXF1aXJlLCBlY2hvID0gRiwgaW5jbHVkZSA9IEZ9CnJlcXVpcmUodGlkeXZlcnNlKQpyZXF1aXJlKGlncmFwaCkKcmVxdWlyZShzaGlueSkKcmVxdWlyZShSU2llbmEpCnJlcXVpcmUocm1kZm9ybWF0cykKcmVxdWlyZShwcmV0dHlkb2MpCnJlcXVpcmUoaHJicnRoZW1lcykKcmVxdWlyZSh0aW50KQpyZXF1aXJlKHR1ZnRlKQpyZXF1aXJlKHBzeWNoKQpgYGAKCgpgYGB7ciB6YWNoYXJ5fQpsaWJyYXJ5KGlncmFwaCkKemFjaCA8LSBpZ3JhcGg6Om1ha2VfZ3JhcGgoKQpwbG90KHphY2gpCmBgYAoKYGBge3IgYWRqYWNlbmN5LCBpbmNsdWRlID0gRiwgZWNobyA9IFR9CnphY2hfYWRqYWNlbnQgPC0gaWdyYXBoOjphc19hZGphY2VuY3lfbWF0cml4KHphY2gsIHR5cGUgPSAiYm90aCIsIHNwYXJzZSA9IEYpCnphY2hfYWRqYWNlbnQKYGBgCgpgYGB7ciBkZXNjcmlwdGl2ZXN9CnZjb3VudCh6YWNoKQppZ3JhcGg6OmVjb3VudCh6YWNoKQppZ3JhcGg6OmRlZ3JlZSh6YWNoKQp0cmFuc2l0aXZpdHkoemFjaCwgdHlwZSA9IGMoImxvY2FsdW5kaXJlY3RlZCIpLCBpc29sYXRlcyA9IGMoIk5hTiIsICJ6ZXJvIikpCiNpZ3JhcGg6OmJldHdlZW5uZXNzKHphY2hfYWRqYWNlbmN5KQpgYGAKCmBgYHtyIGR5YWQgYW5kIHRyaWFkIGNlbnN1c30KaWdyYXBoOjpkeWFkX2NlbnN1cyh6YWNoKSAjbXV0dWFsLCBhc3ltZXRyaWMsIG5vIHJlbGF0aW9ucyBiZXR3ZWVuIHR3byB2ZXJ0aWNlcyAtLSBlbiBhbHMgamUgMCBhc3ltZXRyaXNjaCB6aWV0LCBkYW4gd2VldCBqZSB1bmRpcmVjdGVkCiNkaXJlY3RlZCBvZiB1bmRpcmVjdGVkIG5ldHdlcmsKI2hvdyBpcyB0cmFuc2l0aXZpdHkgZGVmaW5lZCBpbiBlZW4gdW5kaXJlY3RlZCBuZXR3ZXJrCmlncmFwaDo6dHJpYWRfY2Vuc3VzKHphY2gpI3NvIGhvdyBhcmUgdGhleSAiZG9pbiciCiN0cmlhZC5jZW5zdXMoemFjaF9hZGphY2VudCkgI2xvdmVseQpgYGAKCk5vdyB3ZSBjYWxjdWxhdGUgdGhlIGdsb2JhbCB0cmFuc2l0aXZpdHkgb2YgdGhlIG5ldHdvcmsuIFRoZSBmb3JtdWxhIHRvIGFjaGlldmUgdGhpcyBpczoKCmBgYHtyIGNhbGN1bGF0aW9ucyB9CnRyYW5zaXRpdml0eSh6YWNoLCB0eXBlID0gImdsb2JhbCIpCmEgPC0gMTU3NQpiIDwtIDMqNDUgKzM5MwpiL2EKYGBgCgojIyBBZGp1c3RpbmcgdGhlIEdyYXBoCgpTbywgbGV0cyBhZGp1c3QgdGhlIGdyYXBoIGFjY29yZGluZyB0byBzb21lIGFzcGVjdHMgb2YgdGhlIHZlcnRpY2VzIGluY2x1ZGVkLiAKCmBgYHtyIHBsb3QgemFjaCBhZ2Fpbn0KVih6YWNoKSRzaXplIDwtYmV0d2Vlbm5lc3MoemFjaCwgbm9ybWFsaXplZCA9IFQsIGRpcmVjdGVkID0gRikgKiA2MCArIDEwICNncm90ZSA9ICo2MCwgZW4gZGUgYW5kZXIgd2lsbGVuIHdlIHdlbCB6aWVuLCBkdXMgbWluaW1hYWwgMTAgKHZvb3IgZGVnZW5lIG1ldCAwKQppZ3JhcGg6OnBsb3QuaWdyYXBoKHphY2gpCmBgYAoKVGhlbiB3ZSB3YW50IHRoZSBub2Rlc3MgdG8gYmUgZnVydGhlciBhcGFydCwgc28gd2UgY2FuIG1vcmUgZWFzaWx5IHNlZSB3aGF0J3MgZ29pbmcgb25lIGhlcmUgCgpgYGB7ciBtZHMgc2V0IHNlZWR9CnNldC5zZWVkKDIzNDUpCm1kcyA8LSBsYXlvdXRfd2l0aF9tZHMoemFjaCkKaWdyYXBoOjpwbG90LmlncmFwaCh6YWNoLCBsYXlvdXQgPSBtZHMpI29rIGRpdCBpcyBub2cgc3RlZWRzIGJlc3QgbGVsaWprIGVpZ2VubGlqaywgd2FudCAzMyBlbiAzNCB6aXR0ZW4gb3AgZGV6ZWxmZGUgcGxlayAtLSB0ZSB2ZWVsIG92ZXJsYXAKYGBgCgouLi4gZG8gc29tZXRoaW5nIHdpdGggdGhlIGNvb3JkaW5hdGVzIHRoZW4gCgpgYGB7ciBtZHMgbGF5b3V0fQptZHMKbWRzWzEsMV0gPC0gNAptZHNbMzQsMV0gPC0tMy41CmlncmFwaDo6cGxvdC5pZ3JhcGgoemFjaCwgbGF5b3V0ID0gbWRzKQpgYGAKCmBgYHtyIGlncmFwaCBsZWdlbmR9CmlncmFwaDo6cGxvdC5pZ3JhcGgoemFjaCwgbGF5b3V0ID0gbWRzLCBtYXJnaW4gPSBjKDAsMCwwLDApKSAKbGVnZW5kKCh4ID0gImJvdHRvbSIsIGMoIk5vdGU6IHRoZSBwb3NpdGlvbiBub2RlcyAxIGFuZCAzNCBoYXZlIGJlZW4gc2V0IGJ5IEpvY2hlbSBUb2xzbWEgKGFuZCByZXByb2R1Y2VkIGJ5IEhhbm5haClcbiB0byBiZSBzZXQgaW4gYSBzcGVjaWZpYyBwb3NpdGlvbiAtLSBhbmQgdGh1cyBkbyBub3QgcmVmbGVjdCB0aGUgcHJvcGVydGllcyBvZiB0aGUgbWRzIGFsZ29yaXRtLiIpLCBidHkgPSAibiIsIGNleCA9IC42KQpgYGAKCiMgIlR3aXR0ZXJzcGhlcmUgaW4gdGhlIER1dGNoIEhvUCIKCkdldCBzb21lIG9mIHRoZSBYIChmb3JtZXJseSBrbm93biBhcyBUd2l0dGVyKSBpbmZvIG9mIE1lbWJlcnMgb2YgUGFybGlhbWVudCwgYW5kIGluZm8gYWJvdXQgdGhlIGFjdG9ycyB0aGVtc2VsdmVzLiAKYGBge3IgdHdpdHRlciBkb3dubGFvZH0KbG9hZCgidHdpdHRlcl8yMDE5MDkxOS5SRGF0YSIpCnN0cih0d2l0dGVyXzIwMTkwOTE5LCAxKQpgYGAKClRoZW4gZXh0cmFjdCBzb21lIGluZm8gYWJvdXQgdGhlaXIgY2hhcmFjdGVyaXN0aWNzLiAKCmBgYCB7ciB0d2l0dGVyIGluZm99CmtleWYgPC0gdHdpdHRlcl8yMDE5MDkxOVtbMV1dICNkZiBvbiAxNDcgZHV0Y2ggbXAncwp0d2l0dGVyIDwtIHR3aXR0ZXJfMjAxOTA5MTlbWzJdXSAjb2JqZWN0IHdlIGNhbiBhbmFseXNlIGluIFJTaWVuYQpzZWF0cyA8LSB0d2l0dGVyXzIwMTkwOTE5IFtbM11dICMgY29vcmRpbmF0ZXMgb2YgdGhlIHNlYXRzIGluIEhvUApmbmV0IDwtIHR3aXR0ZXIkZGVwdmFycyRmbmV0ICMgd2hvIGZvbGxvd3Mgd2hvbQphdG1uZXQgPC0gdHdpdHRlciRkZXB2YXJzJGF0bW5ldCAjIHdobyBhdG1lbnRpb25zIHdob20KcnRuZXQgPC0gdHdpdHRlciRkZXB2YXJzJHJ0bmV0ICMgd2hvIHJldHdlYXRzIHdob20KdnJvdXcgPC0gdHdpdHRlciRjQ292YXJzJHZyb3V3ICNnZW5kZXIKcGFydGlqIDwtIHR3aXR0ZXIkY0NvdmFycyRwYXJ0aWogI3BhcnRpagpldGhtaW56IDwtIHR3aXR0ZXIkY0NvdmFycyRldGhtaW56ICNldGhuaWMgbWlub3JpdHkKbGZ0IDwtIHR3aXR0ZXIkY0NvdmFycyRsZnQgI2FnZSAKI2RlLWNlbnRyYWxpc2UgdmFsdWVzIApldGhtaW56IDwtIGV0aG1pbnogKyBhdHRyaWJ1dGVzKGV0aG1pbnopJG1lYW4KcGFydGlqIDwtIHBhcnRpaiArIGF0dHJpYnV0ZXMocGFydGlqKSRtZWFuCnZyb3V3IDwtIHZyb3V3ICsgYXR0cmlidXRlcyh2cm91dykkbWVhbgpsZnQgPC0gbGZ0ICsgYXR0cmlidXRlcyhsZnQpJG1lYW4KYGBgCgpIYXZpbmcgZXh0cmFjdGVkIGFuZCBkZWZpbmVkIHRoZSB2YXJpYWJsZXMgb2YgaW1wb3J0LCB3ZSdsbCBub3cgaW52ZXN0aWdhdGUgdGhlIGRhdGFzZXQvc3RydWN0dXJlIG9mIHRoZSBkYXRhLiAKCmBgYHtyIHN0cnVjdHVyZSBmcmllbmRzaGlwIG5ldHd9CnN0cihmbmV0KSAjdGhlIHN0cnVjdHVyZSBvZiB0aGUgZnJpZW5kc2hpcCBuZXR3b3JrCnZpZXcoZm5ldCkKYGBgCgpGcm9tIGFsbCB0aGVzZSBkYXRhLCB3ZSBzZWxlY3QgdmVyeSBzcGVjaWZpYyBtYXRyaWNlczogZnJpZW5kc2hpcCAoZm9sbG93ZXIpIG5ldHdvcmsgd2F2ZSAxLCBhbmQgdGhlICJAbWVudGlvbnMiIGZvciB3YXZlIDEsIDIsIGFuZCAzIC4uLiAKCmBgYHtyIHNlbGVjdCBtYXRyaWNlc30KZm5ldDEgPC0gZm5ldFssICwgMV0gICNmcmllbmRzaGlwIG5ldHdvcmsgd2F2ZSAxCmF0bW5ldDEgPC0gYXRtbmV0WywgLCAxXSAgI2F0bWVudGlvbiBuZXR3b3JrIHdhdmUgMQojIHdlIHdpbGwgdXNlIHdhdmUgMiBhbmQgMyBsYXRlci4KYXRtbmV0MiA8LSBhdG1uZXRbLCAsIDJdICNhdG1lbnRpb24gbmV0d29yayB3YXZlIDIKYXRtbmV0MyA8LSBhdG1uZXRbLCAsIDNdICNhdG1lbnRpb24gbmV0d29yayB3YXZlIDMKYGBgCgouLi4gYW5kIHRoZW4sIGZvciBvdXIgbGFzdCB0cmljaywgd2UgcmVwbGFjZSBtaXNzaW5nIHZhbHVlcyBpbiBSU2llbmEgCgpgYGB7ciBtaXNzaW5nIHZhbHVlc30KZm5ldDFbZm5ldCA9PSAxMF0gPC0gMAphdG1uZXQxW2F0bW5ldDEgPT0gMTBdIDwtIDAKYXRtbmV0MlthdG1uZXQyID09IDEwXSA8LSAwCmF0bW5ldDNbYXRtbmV0MyA9PSAxMF0gPC0gMApgYGAKCiMjIFRoZSBGdW4gU3R1ZmYKTm93IHdlcmUgZ29ubmEgZG8gc29tZSByZWFsIGZ1biB0aGluZ3MsIGxldCdzIGJlZ2luIGJ5IG1ha2luZyBhIGdyYXBoIGZyb20gdGhlIGF0bW5ldDEgaW5mb3JtYXRpb246CgpgYGB7ciBrZXlmfQoKYXRtbmV0MV9ncmFwaCA8LSBpZ3JhcGg6OmdyYXBoX2Zyb21fYWRqYWNlbmN5X21hdHJpeChhdG1uZXQxLCBtb2RlID0gImRpcmVjdGVkIiwgd2VpZ2h0ZWQgPSBOVUxMLCBkaWFnID0gVCwgYWRkLmNvbG5hbWVzID0gTkEsIGFkZC5yb3duYW1lcyA9IE5BKQoKYXRtbmV0MV9lZGdlcyA8LSBhc19kYXRhX2ZyYW1lKGF0bW5ldDFfZ3JhcGgsIHdoYXQgPSAiZWRnZXMiKQoKa2V5ZiA8LSBjYmluZChrZXlmJEVHT2lkLCBrZXlmWyAsbmFtZXMoa2V5ZikgIT0gIkVHT2lkIl0pCgpuYW1lcyhrZXlmKVsxXSA8LSAiRUdPaWQiCgphdG1uZXQxX2dyYXBoIDwtIGdyYXBoX2Zyb21fZGF0YV9mcmFtZShhdG1uZXQxX2VkZ2VzLCBkaXJlY3RlZCA9IFQsIHZlcnRpY2VzID0ga2V5ZikKI25vdyBwbG90IQpwbG90KGF0bW5ldDFfZ3JhcGgpICNhbGwgdGhvc2UgbG9uZXJzCmBgYAoKdGhlIGRvd25zaXplIG9mIHRoZSBwbG90IHdlIGhhdmUganVzdCAuLi4gd2VsbCAuLi4gcGxvdHRlZCwgaXMgdGhhdCBpdCBpcyBob3JyaWJseSBpbGxlZ2libGUuIExldCdzIHNlZSBpZiB3ZSBjYW4gaW50cm9kdWNlIHNvbWUgbGVnaWJpbGl5IHRvIGluZHVjZSBzb21lIHVzZWZ1bG5lc3MuCgpgYGB7ciBzaW1wbGUgcGxvdCBhfQojZmlyc3QsIGRvZXMgW3NpbXBsaWZ5XSBkbyBhbnl0aGluZz8KYXRtbmV0MV9ncmFwaCA8LSBzaW1wbGlmeShhdG1uZXQxX2dyYXBoKQpwbG90KGF0bW5ldDFfZ3JhcGgpICNzb21ldGhpbmcgaGFwcGVucywgbm90aGluZyB1c2VmdWwgdGhvCmVkZ2VfZGVuc2l0eShhdG1uZXQxX2dyYXBoKSAjZGVuc2l0eSBvZiB0aGUgbmV0d29yayBkb2VzIG5vdCBleHBsYWluIHRoZSBkZW5zaXR5IG9mIHRoZSBncmFwaC4gc28gd2UncmUgZ29ubmEgaGF2ZSB0byBmaW5kIHNvbWUgb3RoZXIgc29sdXRpb25zCmBgYAoKIyMjIERpcmVjdGVkIGFuZCByZWNpcHJvY2F0ZWQgdGllcyAtLSBhIGRpZmZlcmVudGlhdGlvbgoKYGBge3IgZ3JhcGggMn0KYXRtbmV0MV91biA8LSBhdG1uZXQxID09IDEgJiB0KGF0bW5ldDEpID09IDEKYXRtbmV0MV9ncmFwaDIgPC0gZ3JhcGhfZnJvbV9hZGphY2VuY3lfbWF0cml4KGF0bW5ldDFfdW4sIG1vZGUgPSAidW5kaXJlY3RlZCIsIHdlaWdodGVkID0gTlVMTCwgZGlhZyA9IFQsIGFkZC5jb2xuYW1lcyA9IE5BLCBhZGQucm93bmFtZXMgPSBOQSkKZWRnZXNfYXRtbmV0MV91biA8LSBhc19kYXRhX2ZyYW1lKGF0bW5ldDFfZ3JhcGgyLCB3aGF0ID0gImVkZ2VzIikKYXRtbmV0MV9ncmFwaDIgPC0gZ3JhcGhfZnJvbV9kYXRhX2ZyYW1lKGVkZ2VzX2F0bW5ldDFfdW4sIGRpcmVjdGVkID0gRiwgdmVydGljZXMgPSBrZXlmKQpwbG90KGF0bW5ldDFfZ3JhcGgyKSAjIGEgbG9vcHkgYml0Y2ggKHNlbGYtbWVudGlvbikKYXRtbmV0MV9ncmFwaDIgPC0gc2ltcGxpZnkoYXRtbmV0MV9ncmFwaDIpCnBsb3QoYXRtbmV0MV9ncmFwaDIsIG1vZGUgPSAidW5kaXJlY3RlZCIpCmBgYAoKIyMjIFNlbGVjdCBOb2RlcyB0byBQbG90CmBgYHtyIHNlbGVjdCBub2RlcyB0byBwbG90fQojZ2V0IHJpZCBvZiBNUCdzIHdobyBvbmx5IG1lbnRpb24gdGhlbXNlbHZlcwpkaWFnKGF0bW5ldDFfdW4pIDwtIDAKI2ZpbmQgdGhlIG5vaXNvbGF0ZXMgKGlzb2xhdGU/KQpub2lzb2xhdGVzIDwtIHJvd1N1bXMoYXRtbmV0MV91biwgbmEucm0gPSBUKSA+IDAKYXRtbmV0MV91bl9zZWwgPC0gYXRtbmV0MV91bltub2lzb2xhdGVzLCBub2lzb2xhdGVzXQpsZW5ndGgobm9pc29sYXRlcykKa2V5Zl9zZWwgPC0ga2V5Zltub2lzb2xhdGVzLCBdCmF0bW5ldDFfZ3JhcGgyX3NlbCA8LSBncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgoYXRtbmV0MV91bl9zZWwsIG1vZGUgPSAidW5kaXJlY3RlZCIsIHdlaWdodGVkID0gTlVMTCwgZGlhZyA9IFQsIGFkZC5jb2xuYW1lcyA9IE5BLCBhZGQucm93bmFtZXMgPSBOQSkKYXRtbmV0MV9ncmFwaDJfc2VsIDwtIHNpbXBsaWZ5KGF0bW5ldDFfZ3JhcGgyX3NlbCkKcGxvdChhdG1uZXQxX2dyYXBoMl9zZWwsIG1vZGUgPSAidW5kaXJlY3RlZCIpCmBgYAoKLi4uIG9yIGFub3RoZXIgY2hhcmFjdGVyaXN0aWMgLS0gcGFydHkgKFZWRCk6IAoKYGBge3IgZ2VuZGVyIG9yIHZ2ZH0KIyBvcHRpb24gMTogc2VlIGFib3ZlLiAgb25seSBzZWxlY3QgTVBzIGZyb20gdGhlIGxpYmVyYWwgcGFydHkKc2VsZWN0aW9uIDwtIGtleWYkUGFydGlqID09ICJWVkQiCiMgYnVpbGQgbmV3IGFkamFjZW5jeSBtYXRyaXgKYXRtbmV0MV91bl9zZWwyIDwtIGF0bW5ldDFfdW5bc2VsZWN0aW9uLCBzZWxlY3Rpb25dCiMgZXRjLgoKIyBvcHRpb24gMi4gU3VwcG9zZSB3ZSBoYXZlIGF0dGFjaGVkIG91ciBkYXRhc2V0IHRvIG91ciBncmFwaCBvYmplY3QuICBvbmx5IHNlbGVjdCBNUHMgZnJvbSB0aGUKIyBsaWJlcmFsIHBhcnR5CnNlbGVjdGlvbiA8LSBWKGF0bW5ldDFfZ3JhcGgyX3NlbCkkUGFydGlqID09ICJWVkQiCnNlbGVjdGlvbl9pZCA8LSB3aGljaChzZWxlY3Rpb24pICAjIHRoaXMgZ2l2ZXMgdXMgYSBudW1lcmljIHZhcmlhYmxlCkdfc2VsIDwtIGluZHVjZWRfc3ViZ3JhcGgoYXRtbmV0MV9ncmFwaDJfc2VsLCB2ID0gc2VsZWN0aW9uX2lkKQpwbG90KEdfc2VsKQpgYGAKCi4uLiB3ZSBjYW4gYWxzbyBjaGFuZ2UgdGhlIHNpemUgb2YgdGhlIHZlcnRpY2VzIC4uLgoKYGBge3IgY2hhbmdlIHZlcnRpeCBzaXplfQpWKGF0bW5ldDFfZ3JhcGgyX3NlbCkkc2l6ZSA8LSBkZWdyZWUoYXRtbmV0MV9ncmFwaDJfc2VsKSoxLjMKcGxvdChhdG1uZXQxX2dyYXBoMl9zZWwsIG1vZGUgPSAidW5kaXJlY3RlZCIpCmBgYAoKLi4uIG9yIGNvcnJlbGF0ZSBjb2xvdXIgYW5kIGxhYmVsIC4uLgoKYGBge3IgbGFiZWwgY29sb3VyIH0KVihhdG1uZXQxX2dyYXBoMikKVihhdG1uZXQxX2dyYXBoMikkbGFiZWwgPC0gIGFzLmNoYXJhY3RlcihWKGF0bW5ldDFfZ3JhcGgyKSROYWFtMikKVihhdG1uZXQxX2dyYXBoMikkbGFiZWwuY2V4ID0gMQpWKGF0bW5ldDFfZ3JhcGgyKSRjb2xvdXIgPC0gaWZlbHNlKFYoYXRtbmV0MV9ncmFwaDIpJEdlc2xhY2h0ID09ICJ2cm91dyIsICJyZWQiLCAiYmx1ZSIpCnBsb3QoYXRtbmV0MV9ncmFwaDIsIG1vZGUgPSAidW5kaXJlY3RlZCIpCiNvciBub3QKYGBgCgouLi4gY3VydmUgdGhlIGVkZ2VzIC4uLgoKYGBge3IgY3Vydnl9CkUoYXRtbmV0MV9ncmFwaDIpJGFycm93LnNpemUgPSAuNApFKGF0bW5ldDFfZ3JhcGgyKSRjdXJ2ZWQgPSAuMwpwbG90KGF0bW5ldDFfZ3JhcGgyLCBtb2RlID0gInVuZGlyZWN0ZWQiKSAjb2sgaSBmdWNrZWQgdXAgbXkgZWRnZXMgc29tZXdoZXJlIGFsb25nIHRoZSB3YXkgaSBndWVzcwpgYGAKCi4uLiBhZGQgYSBsZWdlbmQgLi4uCgpgYGB7ciBwbG90IGdyYXBoMn0KcGxvdC5pZ3JhcGgoYXRtbmV0MV9ncmFwaDIsIG1hcmdpbiA9IDAsIG1vZGUgPSAidWRpcmVjdGVkIikKbGVnZW5kKHggPSAtMSwgeSA9IC0xLCBjKCJGZW1hbGUiLCAiTWFsZSIpLCBwY2ggPSAyMSwgY29sID0gIiM3Nzc3NzciLCBwdC5iZyA9IGMoInJlZCIsICJncmVlbiIpLCBwdC5jZXggPSAyLAogICAgY2V4ID0gMC44LCBidHkgPSAibiIsIG5jb2wgPSAxKQpgYGAKCiMgUGFybGlhbWVudCAKCmBgYHtyIHBsb3Qgd2l0aCBhbGwgY2hhcmFjdGVyaXN0aWNzfQoja25pdHI6OmluY2x1ZGVfZ3JhcGhpY3MoIlRLLmpwZyIpCnBsb3Qoa2V5ZiRYLCBrZXlmJFksIHhsaW0gPSBjKC0xOCwgMTgpLCB5bGltID0gYygtMTgsIDE4KSwgY29sID0ga2V5ZiRQYXJ0aWpfY29sLCBwY2ggPSAxNikKYGBgCgphZGp1c3Qgc29tZXRoaW5nIAoKYGBge3IgcGFydGllc30KI2dpdmUgbm9kZXMgY29sb3VyIHRvIHBhcnRpZXMKVihhdG1uZXQxX2dyYXBoMikkY29sb3IgPC0ga2V5ZiRQYXJ0aWpfY29sCgojIGNoYW5nZSBub2RlIHNpemUgYSBiaXQKVihhdG1uZXQxX2dyYXBoMikkc2l6ZSA9IGlncmFwaDo6ZGVncmVlKGF0bW5ldDFfZ3JhcGgyKSAqIDEuMDUgKyA2CgojIHJlbW92ZSB0aGUgbGFiZWxzClYoYXRtbmV0MV9ncmFwaDIpJGxhYmVsID0gIiIKCiMgbGVzcyBjdXJ2YXR1cmUKRShhdG1uZXQxX2dyYXBoMikkY3VydmVkID0gMC4xCgpvd25jb29yZHMgPC0gY2JpbmQoa2V5ZiRYLCBrZXlmJFkpCm93bmNvb3JkcyA8LSBvd25jb29yZHMvOApvd25jb29yZHNbLCAxXSA8LSAob3duY29vcmRzWywgMV0gLSBtZWFuKG93bmNvb3Jkc1ssIDFdKSkKb3duY29vcmRzWywgMl0gPC0gKG93bmNvb3Jkc1ssIDJdIC0gbWVhbihvd25jb29yZHNbLCAyXSkpCnBsb3QuaWdyYXBoKGF0bW5ldDFfZ3JhcGgyLCBtb2RlID0gInVuZGlyZWN0ZWQiLCBsYXlvdXQgPSBvd25jb29yZHMsIHJlc2NhbGUgPSBGLCBtYXJnaW4gPSBjKDAsIDAsIDAsIDApLCB4bGltID0gYyhtaW4ob3duY29vcmRzWywKICAgIDFdKSwgbWF4KG93bmNvb3Jkc1ssIDFdKSksIHlsaW0gPSBjKG1pbihvd25jb29yZHNbLCAyXSksIG1heChvd25jb29yZHNbLCAyXSkpKQpgYGAKCi4uLiBjaGFuZ2Ugc29tZSBlZGdlcyAuLi4gCgpgYGB7ciBlZGdlcyBwbGFhdGplfQojIGNvbnN0cnVjdCBhZGphY2VuY3kgbWF0cml4IGZpcnN0IGRlZmluZSB0aGUgcmVjaXByaWNhdGVkIGF0bWVudGlvbnMgaW4gZWFjaCB3YXZlCmF0bW5ldDFfdW4gPC0gYXRtbmV0MSA9PSAxICYgdChhdG1uZXQxKSA9PSAxCmF0bW5ldDJfdW4gPC0gYXRtbmV0MiA9PSAxICYgdChhdG1uZXQyKSA9PSAxCmF0bW5ldDNfdW4gPC0gYXRtbmV0MyA9PSAxICYgdChhdG1uZXQzKSA9PSAxCgphdG1uZXRfd2VpZ2h0ZWQgPC0gYXRtbmV0MV91biArIGF0bW5ldDJfdW4gKyBhdG1uZXQzX3VuCgojIGNvbnRzdHJ1Y3QgZ3JhcGggLyBsZXQgdXMga2VlcCB0aGUgbG9vcHMgbm90ZSB0aGF0IHRoZSBwYXJhbWV0ZXIgJ3dlaWdodGVkJyBpcyBzZXQgdG8gdHJ1ZS4KR193IDwtIGlncmFwaDo6Z3JhcGhfZnJvbV9hZGphY2VuY3lfbWF0cml4KGF0bW5ldF93ZWlnaHRlZCwgbW9kZSA9ICJ1bmRpcmVjdGVkIiwgd2VpZ2h0ZWQgPSBUUlVFLCBkaWFnID0gVFJVRSwKICAgIGFkZC5jb2xuYW1lcyA9IE5BLCBhZGQucm93bmFtZXMgPSBOQSkKCiMgYXR0YWNoIGRhdGEKZWRnZXMgPC0gaWdyYXBoOjphc19kYXRhX2ZyYW1lKEdfdywgd2hhdCA9ICJlZGdlcyIpCiMgaW5zcGVjdCB0aGUgd2VpZ2h0LgplZGdlcyR3ZWlnaHQgICNub3QgYSBsb3Qgb2YgdmFyaWF0aW9uLiAKCiMgcmVidWlsZCB0aGUgZ3JhcGguCkdfdyA8LSBncmFwaF9mcm9tX2RhdGFfZnJhbWUoZWRnZXMsIGRpcmVjdGVkID0gRkFMU0UsIHZlcnRpY2VzID0ga2V5ZikKCgoKIyBhZGQgY2hhbmdlcyBhcyBhYm92ZQpWKEdfdykkY29sb3IgPC0ga2V5ZiRQYXJ0aWpfY29sClYoR193KSRzaXplID0gaWdyYXBoOjpkZWdyZWUoR193KSAqIDEuMDUgKyA2ClYoR193KSRsYWJlbCA9ICIiCkUoR193KSRjdXJ2ZWQgPSAwLjEKCiMgYWRkIHRoZSB3ZWlnaHRzCkUoR193KSR3aWR0aCA8LSBFKEdfdykkd2VpZ2h0CgpwbG90LmlncmFwaChHX3csIG1vZGUgPSAidW5kaXJlY3RlZCIsIGxheW91dCA9IG93bmNvb3JkcywgcmVzY2FsZSA9IEYsIG1hcmdpbiA9IGMoMCwgMCwgMCwgMCksIHhsaW0gPSBjKG1pbihvd25jb29yZHNbLAogICAgMV0pLCBtYXgob3duY29vcmRzWywgMV0pKSwgeWxpbSA9IGMobWluKG93bmNvb3Jkc1ssIDJdKSwgbWF4KG93bmNvb3Jkc1ssIDJdKSkpCmBgYAoKLi4uIGNoYW5nZSB0aGUgZWRnZXMgYmFzZWQgb24gZHlhZHMgLi4uIAoKYGBge3IgZWRnZXMgYmFzZWQgb24gZHlhZHN9CiMgbGV0IHVzIG1ha2UgdGhlbSB0aGUgY29sb3Igb2YgdGhlIG5vZGVzIGlmIGl0IGlzIGJldHdlZW4gbm9kZXMgZnJvbSBzYW1lIHBhcnR5LiAgbGV0IHVzIG1ha2UgdGhlbQojIHJlZCBpZiBiZXR3ZWVuIHBhcnRpZXMKCmVkZ2VzIDwtIGFzX2FkamFjZW5jeV9tYXRyaXgoR193KQplZGdlc19tYXQgPC0gbWF0cml4KGFzLm51bWVyaWMoZWRnZXMpLCBucm93ID0gbnJvdyhlZGdlcykpCiMgZWRnZXNfbWF0CgojIGJlY2F1c2Ugd2UgaGF2ZSB1bmRpcmVjdGVkLCB3ZSBvbmx5IG5lZWQgdGhlIGVkZ2VzIG9uY2UgLi4uSSBrbm93IC4uLgplZGdlc19tYXRbbG93ZXIudHJpKGVkZ2VzX21hdCldIDwtIDAKIyB0YWJsZShrZXlmJEdlc2xhY2h0KQoKdGVsbGVyIDwtIDEKY29sb3JlZGdlcyA8LSBOQQojIHdlIHdpbGwgbG9vcCBvdmVyIGVnb3MKZm9yIChpIGluIDE6bnJvdyhlZGdlcykpIHsKICAgICMgV2UgdGhlbiBsb29wIG92ZXIgYWx0ZXJzCiAgICBmb3IgKGogaW4gMTpuY29sKGVkZ2VzKSkgewogICAgICAgICMgd2UgY2hlY2sgaWYgdGhlcmUgaXMgYSB0aWUgYmV0d2VlbiBlZ28gYW5kIGFsdGVyCiAgICAgICAgaWYgKGVkZ2VzX21hdFtpLCBqXSA9PSAxKSB7CiAgICAgICAgICAgICMgaWYgc28sIHdlIGNoZWNrIGVnbyBhbmQgYWx0ZXIgYXJlIGZyb20gdGhlIHNhbWUgcGFydHkgaWYgc28sIHdlIGdpdmUgdGhlIHRpZSB0aGUKICAgICAgICAgICAgIyBjb2xvciBvZiB0aGUgcGFydHkKICAgICAgICAgICAgaWYgKGtleWYkUGFydGlqX2NvbFtpXSA9PSBrZXlmJFBhcnRpal9jb2xbal0pIHsKICAgICAgICAgICAgICAgIGNvbG9yZWRnZXNbdGVsbGVyXSA8LSBrZXlmJFBhcnRpal9jb2xbaV0KICAgICAgICAgICAgfQogICAgICAgICAgICAjIGlmIHNvLCB3ZSBjaGVjayBlZ28gYW5kIGFsdGVyIGFyZSBmcm9tIHRoZSBzYW1lIHBhcnR5IGlmIG5vdCwgd2UgZ2l2ZSB0aGUgdGllIGEKICAgICAgICAgICAgIyB0cmFuc3BhcmVudCBncmV5IGNvbG9yCiAgICAgICAgICAgIGlmIChrZXlmJFBhcnRpal9jb2xbaV0gIT0ga2V5ZiRQYXJ0aWpfY29sW2pdKSB7CiAgICAgICAgICAgICAgICBjb2xvcmVkZ2VzW3RlbGxlcl0gPC0gIiMwMDAwMDA0QiIKICAgICAgICAgICAgfQogICAgICAgICAgICB0ZWxsZXIgPC0gdGVsbGVyICsgMQogICAgICAgIH0KICAgIH0KfQoKRShHX3cpJGNvbG9yID0gY29sb3JlZGdlcwoKIyBwcmVwYXJlIGEgbGVnZW5kClBhcnR5X25hbWVzIDwtIHVuaXF1ZShrZXlmJFBhcnRpaikKUGFydHlfY29scyA8LSB1bmlxdWUoa2V5ZiRQYXJ0aWpfY29sKQojIHJlb3JkZXIKUGFydHlfbmFtZXMgPC0gUGFydHlfbmFtZXNbYyg3LCAzLCA5LCAxMCwgMTIsIDExLCA1LCA0LCA2LCAyLCA4LCAxLCAxMyldClBhcnR5X2NvbHMgPC0gUGFydHlfY29sc1tjKDcsIDMsIDksIDEwLCAxMiwgMTEsIDUsIDQsIDYsIDIsIDgsIDEsIDEzKV0KCiNzYXZlIHRoZSBwbG90IHBuZygnTVBwbG90djIucG5nJyx3aWR0aCA9IDkwMCwgaGVpZ2h0PSA5MDApCnsKCiAgICBwbG90LmlncmFwaChHX3csIG1vZGUgPSAidW5kaXJlY3RlZCIsIGxheW91dCA9IG93bmNvb3JkcywgcmVzY2FsZSA9IEYsIG1hcmdpbiA9IGMoMCwgMCwgMCwgMCksIHhsaW0gPSBjKG1pbihvd25jb29yZHNbLAogICAgICAgIDFdKSwgbWF4KG93bmNvb3Jkc1ssIDFdKSksIHlsaW0gPSBjKG1pbihvd25jb29yZHNbLCAyXSksIG1heChvd25jb29yZHNbLCAyXSkpKQoKICAgIGxlZ2VuZCgidG9wbGVmdCIsIGxlZ2VuZCA9IFBhcnR5X25hbWVzLCBwY2ggPSAyMSwgY29sID0gIiM3Nzc3NzciLCBwdC5iZyA9IFBhcnR5X2NvbHMsIHB0LmNleCA9IDIsCiAgICAgICAgY2V4ID0gMC44LCBidHkgPSAibiIsIG5jb2wgPSAzKQoKICAgIHRleHQoLTIuMiwgLTEuMiwgIk5vdGUgMTogTm9kZSBzaXplIGJhc2VkIG9uIGRlZ3JlZSIsIGFkaiA9IDAsIGNleCA9IDAuOCkKICAgIHRleHQoLTIuMiwgLTEuMywgIk5vdGUgMjogRWRnZSBjb2xvciBiYXNlZCBvbiBQYXJ0eSBvZiBNUHMsIGJsYWNrIGlmIE1QcyBmcm9tIGRpZmZlcmVudCBwYXJ0eSIsIGFkaiA9IDAsCiAgICAgICAgY2V4ID0gMC44KQogICAgdGV4dCgtMi4yLCAtMS40LCAiTm90ZSAzOiBFZGdlIHdpZHRoIGJhc2VkIG9uIG51bWJlciBvZiBAbWVudGlvbnMiLCBhZGogPSAwLCBjZXggPSAwLjgpCn0KCiMgZGV2Lm9mZigpCgpgYGAKCiMgQ29sbGFiLiBOZXR3b3JrcwoKYGBge3IgZG93bmxvYWQgc29jaWFsIHRoaW5nc30KIyBsb2FkIHRoZSBuZWNlc3NhcnkgZGF0YXNldHMKbG9hZCgic29jX2RmLlJEYXRhIikKbG9hZCgic29jX2NvbGxhYnMxLlJEYXRhIikKbG9hZCgic29jX2NvbGxhYnMyLlJEYXRhIikKYGBgCgpgYGB7ciBjb2xsYWJvcmF0b3JzIHVuaXF1ZSBhbmQgb3RoZXJzfQojIGdldCB1bmlxdWUgY29sbGFib3JhdG9ycyBvZiBzb2Mgc3RhZmYgZmlyc3QKc29jX2NvbGxhYnNfdW5pcXVlIDwtIHVuaXF1ZShzb2NfY29sbGFic1ssIDRdKSAgIyBzbyAyMjkgdW5pcXVlIGNvbGxhYm9yYXRvcnMgZm9yIFJVIHN0YWZmPwpzb2NfY29sbGFic191bmlxdWUgPC0gYyhzb2NfY29sbGFic191bmlxdWUsIHNvY19kZiRnc19pZCkgICMgYWRkIHRoZSBzb2Mgc3RhZmYgdGhlbXNlbHZlcy4Kc29jX2NvbGxhYnNfdW5pcXVlIDwtIGRhdGEuZnJhbWUoc29jX2NvbGxhYnNfdW5pcXVlKQpzb2NfY29sbGFic191bmlxdWUkdjEgPC0gMSAgIyBjb252ZW5pZW50IHRvIHNlbGVjdCBvbiBhZnRlciB0aGUgbWVyZ2UKc29jX2NvbGxhYnNfdW5pcXVlIDwtIHVuaXF1ZShzb2NfY29sbGFic191bmlxdWUpCgojIHNvIHRoaXMgaXMgYSB2ZXJ5IGltcG9ydGFudCBzdGVwLCB3ZSBqb2luIHRoZSB1bmlxdWUgc29jIGNvbGxhYm9yYXRvcnMgdG8gdGhlIGNvbGxhYm9yYXRvcnMgb2YKIyBjb2xsYWJvcmF0b3JzCnJlcXVpcmUodGlkeXZlcnNlKQpvbmVmaXZlZGVncmVlIDwtIGxlZnRfam9pbihjb2xsYWJzXzFkZWVwLCBzb2NfY29sbGFic191bmlxdWUsIGJ5ID0gYyhjb2F1dGhfaWQgPSAic29jX2NvbGxhYnNfdW5pcXVlIikpCgojIFRoZW4sIHdlIGRyb3AgdGhvc2UgdGhhdCBhcmUgbm90IGFtb25nIHNvY2lvbG9neSBjb2xsYWJvcmF0b3JzIGFuZCB3aG8gZG9uJ3QgbHNpdCBjb2F1dGhvcnMKIyByZWdhcmRsZXNzCm9uZWZpdmVkZWdyZWUgPC0gb25lZml2ZWRlZ3JlZVshaXMubmEob25lZml2ZWRlZ3JlZSR2MSksIF0Kb25lZml2ZWRlZ3JlZSA8LSBvbmVmaXZlZGVncmVlWyFpcy5uYShvbmVmaXZlZGVncmVlJGNvYXV0aCksIF0KCiMgd2UgcGljayB0aG9zZSBjb2x1bW5zIGFuZCBoYXZlIGFuIGVkZ2VsaXN0IG9mIHNvYyBjb2xsYWJvcmF0b3JzIGFuZCB3aGV0aGVyIHRoZXkgY29sbGFib3JhdGUgd2l0aAojIHRob3NlIHNhbWUgY29sbGFib3JhdG9ycyB0aGUgMS41IGRlZ3JlZSBuZXR3b3JrCm9uZWZpdmVkZWdyZWUgPC0gb25lZml2ZWRlZ3JlZVssIGMoIm5hbWUiLCAiY29hdXRoIildCm5hbWVzKG9uZWZpdmVkZWdyZWUpIDwtIGMoImZyb20iLCAidG8iKQoKIyB3ZSBnZXQgc29jIGNvbGxhYm9yYXRvcnMgYW5kIGFkZCB0aG9zZSB0byB0aGUgZGF0YSBhYm92ZSBhbmQgZW5kIHVwIHdpdGggYSBuaWNlIGVkZ2VsaXN0IQpzb2NjIDwtIHNvY19jb2xsYWJzWyFpcy5uYShzb2NfY29sbGFicyRjb2F1dGgpLCBdCnNvY2MgPC0gc29jY1ssIGMoIm5hbWUiLCAiY29hdXRoIildCm5hbWVzKHNvY2MpIDwtIGMoImZyb20iLCAidG8iKQpvbmVmaXZlZGVncmVlIDwtIHJiaW5kKHNvY2MsIG9uZWZpdmVkZWdyZWUpCnNhdmUob25lZml2ZWRlZ3JlZSwgZmlsZSA9ICJzb2Nfb25lZml2ZWRlZ3JlZS5SRGF0YSIpCmBgYAoKYGBge3IgbWF0cml4fQpvbmVmaXZlZGVncmVlIDwtIGFzLm1hdHJpeChvbmVmaXZlZGVncmVlKSAgIyBtYXRyaXggYmVjYXVzZSBpZ3JhcGggd2FudHMgdGhhdApsaWJyYXJ5KGlncmFwaCkgICMgTm90aWNlIHRoYXQgd2UgY2FsbCBpZ3JhcGggaGVyZSwgaW4gYW50aWNpcGF0aW9uIG9mIHRoZSB2aXogdHV0b3JpYWwuCm5ldDEgPC0gZ3JhcGhfZnJvbV9lZGdlbGlzdChvbmVmaXZlZGVncmVlLCBkaXJlY3RlZCA9IFRSVUUpICAjIE5vdGljZSB0aGUgaWdyYXBoIGZ1bmN0aW9uIGhlcmUhCgpwbG90KG5ldDEpICAjIHByZXR0eSB1Z2x5IQpgYGAKCgpgYGB7ciBuZXRzfQpwbG90KG5ldDEgLAogICAgIHZlcnRleC5jb2xvciA9ICJnb2xkIiwgIyBuaWNlIGNvbG9yIGZvciB0aGUgdmVydGljZXMKICAgICB2ZXJ0ZXguc2l6ZSA9IDQsICAjIHdlJ2xsIHZlcnRpY2VzIGEgYml0IHNtYWxsZXIKICAgICB2ZXJ0ZXguZnJhbWUuY29sb3IgPSAiZ3JheSIsICAjIHdlJ2xsIHB1dCBhIGdyYXkgZnJhbWUgYXJvdW5kIHZlcnRpY2VzCiAgICAgdmVydGV4LmxhYmVsLmNvbG9yID0gImJsYWNrIiwgICMgbm90IHRoYXQgdWdseSBibHVlIGNvbG9yIGZvciB0aGUgbGFiZWxzIChuYW1lcykKICAgICB2ZXJ0ZXgubGFiZWwuZmFtaWx5ID0gIkhlbHZldGljYSIsICMgbm90IGEgZmFuIG9mIHRpbWVzIG5ldyByb21hbiBpbiBmaWd1cmVzCiAgICAgdmVydGV4LmxhYmVsLmNleCA9IDAuNCwgICMgbWFrZSB0aGUgbGFiZWwgYSBiaXQgc21hbGxlciB0b28KICAgICB2ZXJ0ZXgubGFiZWwuZGlzdCA9IDAuNSwgICMgd2UnbGwgcHVsbCB0aGUgbGFiZWxzIGEgYml0IGF3YXkgZnJvbSB0aGUgdmVydGljZXMKICAgICBlZGdlLmN1cnZlZCA9IDAuMiwgIyBjdXJ2ZWQgZWRnZXMgaXMgYWx3YXlzIGEgbmljZSB0b3VjaAogICAgIGVkZ2UuYXJyb3cuc2l6ZSA9IDAuMSkgIyBtYWtlIGFycm93IHNpemUgKGRpcmVjdGlvbiBvZiBlZGdlKSBzbWFsbGVyCmBgYAoKYGBge3IgbW9yZSBuZXR3b3JrfQppbl9uZXR3b3JrIDwtIGRhdGEuZnJhbWUoYXNfaWRzKFYobmV0MSkpKQpuYW1lcyhpbl9uZXR3b3JrKVsxXSA8LSAibmFtZSIKCiNzb2NfZGYkdG90YWxfY2l0ZXMgPC0gc29jX2RmJHRvdGFsX2NpdGVzLngKcnVfbm9kZXMgPC0gc29jX2RmWywgYygibmFtZSIsICJ0b3RhbF9jaXRlcyIpXQppbl9uZXR3b3JrIDwtIGxlZnRfam9pbihpbl9uZXR3b3JrLCBydV9ub2RlcywgYnkgPSBjKCJuYW1lIiA9ICJuYW1lIikpCmluX25ldHdvcmskdmNvbCA8LSBpZmVsc2UoaXMubmEoaW5fbmV0d29yayR0b3RhbF9jaXRlcyksICIjRTY5RjAwIiwgIiM1NkI0RTkiKQoKcGxvdChuZXQxLAogICAgIHZlcnRleC5jb2xvciA9IGluX25ldHdvcmskdmNvbCwgI1RISVMgV0FTIFdIQVQgV0UgRElEIFRIRSBMQVNUIENPREVCTE9DSyBGT1IhCiAgICAgdmVydGV4LnNpemUgPSA0LCAgIyB3ZSdsbCBtYWtlIHRoZW0gYSBiaXQgc21hbGxlcgogICAgIHZlcnRleC5mcmFtZS5jb2xvciA9ICJncmF5IiwgICMgd2UnbGwgcHV0IGEgZnJhbWUgYXJvdW5kIGl0CiAgICAgdmVydGV4LmxhYmVsLmNvbG9yID0gImJsYWNrIiwgICMgbm90IHRoYXQgdWdseSBibHVlIGNvbG9yIGZvciB0aGUgbmFtZXMKICAgICB2ZXJ0ZXgubGFiZWwuZmFtaWx5ID0gIkhlbHZldGljYSIsICMgbm90IGEgZmFuIG9mIHRpbWVzIGluIGZpZ3VyZXMKICAgICB2ZXJ0ZXgubGFiZWwuY2V4ID0gMC40LCAgIyBhIGJpdCBzbWFsbGVyIHRvbwogICAgIHZlcnRleC5sYWJlbC5kaXN0ID0gMC41LCAgIyB3ZSdsbCBwdWxsIHRoZSBsYWJlbHMgYSBiaXQgYXdheSBmcm9tIHRoZSB2ZXJ0aWNlcwogICAgIGVkZ2UuY3VydmVkID0gMC4yLCAgIyBjdXJ2ZWQgZWRnZXMgaXMgYWx3YXlzIGEgbmljZSB0b3VnaAogICAgIGVkZ2UuYXJyb3cuc2l6ZSA9IDAuMSkgIyBhcnJvdyBzaXplIHNtYWxsZXIKYGBgCgoKYGBge3IgZXZlbiBtb3JlIG1hbn0KcGxvdChuZXQxLAogICAgIHZlcnRleC5jb2xvciA9IGluX25ldHdvcmskdmNvbCwgCiAgICAgI05PVElDRSBUSEVTRSBDT05ESVRJT05BTCBTVEFURU1FTlRTIEJFTE9XCiAgICAgdmVydGV4LmxhYmVsID0gaWZlbHNlKCFpcy5uYShpbl9uZXR3b3JrJHRvdGFsX2NpdGVzKSwgaW5fbmV0d29yayRuYW1lLCBOQSksCiAgICAgdmVydGV4LnNpemUgPSA0LCAgIyB3ZSdsbCBtYWtlIHRoZW0gYSBiaXQgc21hbGxlcgogICAgIHZlcnRleC5mcmFtZS5jb2xvciA9ICJncmF5IiwgICMgd2UnbGwgcHV0IGEgZnJhbWUgYXJvdW5kIGl0CiAgICAgdmVydGV4LmxhYmVsLmNvbG9yID0gImJsYWNrIiwgICMgbm90IHRoYXQgdWdseSBibHVlIGNvbG9yIGZvciB0aGUgbmFtZXMKICAgICB2ZXJ0ZXgubGFiZWwuZmFtaWx5ID0gIkhlbHZldGljYSIsICMgbm90IGEgZmFuIG9mIHRpbWVzIGluIGZpZ3VyZXMKICAgICB2ZXJ0ZXgubGFiZWwuY2V4ID0gMC42NSwgICMgYSBiaXQgc21hbGxlciB0b28KICAgICB2ZXJ0ZXgubGFiZWwuZGlzdCA9IDAuNSwgICMgd2UnbGwgcHVsbCB0aGUgbGFiZWxzIGEgYml0IGF3YXkgZnJvbSB0aGUgdmVydGljZXMKICAgICBlZGdlLmN1cnZlZCA9IDAuMiwgIyBjdXJ2ZWQgZWRnZXMgaXMgYWx3YXlzIGEgbmljZSB0b3VnaAogICAgIGVkZ2UuYXJyb3cuc2l6ZSA9IDAuMSkgIyBhcnJvdyBzaXplIHNtYWxsZXIKYGBgCgoKYGBge3IgdGhpbmdzIG1vcmUgbW9vb29vcmVlZX0KCnBsb3QobmV0MSwKICAgICB2ZXJ0ZXguY29sb3IgPSBpbl9uZXR3b3JrJHZjb2wsIAogICAgIHZlcnRleC5sYWJlbCA9IGlmZWxzZSghaXMubmEoaW5fbmV0d29yayR0b3RhbF9jaXRlcyksIGluX25ldHdvcmskbmFtZSwgTkEpLAogICAgICMgU0FNRSBIRVJFLCBUUlkgVE8gU01PT1RIIFRIRSBUT1RBTF9DSVRFUyBBIEJJVCBXSVRIIExPR1NDQUxFCiAgICAgdmVydGV4LnNpemUgPSBpZmVsc2UoIWlzLm5hKGluX25ldHdvcmskdG90YWxfY2l0ZXMpLCBsb2coaW5fbmV0d29yayR0b3RhbF9jaXRlcyksIDIpLAogICAgIHZlcnRleC5mcmFtZS5jb2xvciA9ICJncmF5IiwgICMgd2UnbGwgcHV0IGEgZnJhbWUgYXJvdW5kIGl0CiAgICAgdmVydGV4LmxhYmVsLmNvbG9yID0gImJsYWNrIiwgICMgbm90IHRoYXQgdWdseSBibHVlIGNvbG9yIGZvciB0aGUgbmFtZXMKICAgICB2ZXJ0ZXgubGFiZWwuZmFtaWx5ID0gIkhlbHZldGljYSIsICMgbm90IGEgZmFuIG9mIHRpbWVzIGluIGZpZ3VyZXMKICAgICB2ZXJ0ZXgubGFiZWwuY2V4ID0gMC42NSwgICMgYSBiaXQgc21hbGxlciB0b28KICAgICB2ZXJ0ZXgubGFiZWwuZGlzdCA9IDAuNSwgICMgd2UnbGwgcHVsbCB0aGUgbGFiZWxzIGEgYml0IGF3YXkgZnJvbSB0aGUgdmVydGljZXMKICAgICBlZGdlLmN1cnZlZCA9IDAuMiwgIyBjdXJ2ZWQgZWRnZXMgaXMgYWx3YXlzIGEgbmljZSB0b3VnaAogICAgIGVkZ2UuYXJyb3cuc2l6ZSA9IDAuMSkgIyBhcnJvdyBzaXplIHNtYWxsZXIKYGBgCgpgYGB7ciBuZXQxIGV0Y30KbmV0MV9tYXQgPC0gaWdyYXBoOjphc19hZGphY2VuY3lfbWF0cml4KG5ldDEsIHNwYXJzZSA9IEZBTFNFKQoKbmV0MV91biA8LSAobmV0MV9tYXQgKyB0KG5ldDFfbWF0KSkgPiAwCgpuZXQxX3VuIDwtIGdyYXBoX2Zyb21fYWRqYWNlbmN5X21hdHJpeChuZXQxX3VuLCBtb2RlID0gInVuZGlyZWN0ZWQiKQoKbmV0X3NlbCA8LSBpbmR1Y2VkLnN1YmdyYXBoKG5ldDFfdW4sIHZpZHMgPSAoaW5fbmV0d29yayR2Y29sID09ICIjNTZCNEU5IikpCgoKcGxvdChuZXRfc2VsKQoKY2xwIDwtIGNsdXN0ZXJfb3B0aW1hbChuZXRfc2VsKQoKCnBsb3QoY2xwLCBuZXRfc2VsKQpgYGAKCg==</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("Graphs2.Rmd");
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
